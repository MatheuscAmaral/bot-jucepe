"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.viabilityService = void 0;
const Logger_1 = __importDefault(require("./utils/Logger"));
const handler_upload_files_to_spaces_1 = require("../utils/handler-upload-files-to-spaces");
const constants_1 = require("./data/constants");
const randomTimerRange = (min = constants_1.BOT_SPEED_CONFIG.ACTION_DELAY.MIN, max = constants_1.BOT_SPEED_CONFIG.ACTION_DELAY.MAX) => {
    return Math.floor(Math.random() * (max - min + 1) + min);
};
async function ensurePageIsActive(page, operation) {
    if (page.isClosed()) {
        throw new Error(`P√°gina foi fechada antes de: ${operation}`);
    }
    // Verificar se o contexto ainda est√° v√°lido
    try {
        await page.evaluate(() => document.readyState);
    }
    catch (error) {
        throw new Error(`Contexto da p√°gina foi destru√≠do antes de: ${operation}`);
    }
}
// ========== NOVAS FUN√á√ïES PARA CLOUDFLARE ==========
async function takeDebugScreenshot(page, filename, description = "") {
    try {
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
        const screenshotPath = `./debug-screenshots/${timestamp}-${filename}.png`;
        // Criar diret√≥rio se n√£o existir
        const fs = require("fs");
        const path = require("path");
        const dir = path.dirname(screenshotPath);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
        await page.screenshot({
            path: screenshotPath,
            fullPage: true,
            type: "png",
        });
        Logger_1.default.info(`üì∏ Screenshot salvo: ${screenshotPath} ${description ? `- ${description}` : ""}`);
    }
    catch (error) {
        Logger_1.default.warn(`‚ö†Ô∏è Erro ao tirar screenshot: ${error}`);
    }
}
async function waitForCloudflareEnhanced(page, timeout = 45000) {
    Logger_1.default.info("üõ°Ô∏è Aguardando Cloudflare (vers√£o melhorada)...");
    const startTime = Date.now();
    let lastTitle = "";
    while (Date.now() - startTime < timeout) {
        try {
            const currentTitle = await page.title();
            // Se o t√≠tulo mudou e n√£o √© mais Cloudflare
            if (currentTitle !== lastTitle &&
                !currentTitle.includes("Just a moment") &&
                !currentTitle.includes("Checking your browser") &&
                currentTitle !== "" &&
                currentTitle !== "Just a moment...") {
                Logger_1.default.info(`‚úÖ Cloudflare superado! T√≠tulo atual: ${currentTitle}`);
                return true;
            }
            lastTitle = currentTitle;
            // COMPORTAMENTO HUMANO MAIS AVAN√áADO
            await humanLikeBehavior(page);
            // Verificar a cada 3-5 segundos
            await new Promise((resolve) => setTimeout(resolve, 3000 + Math.random() * 2000));
        }
        catch (error) {
            Logger_1.default.warn(`‚ö†Ô∏è Erro durante verifica√ß√£o do Cloudflare: ${error}`);
            await new Promise((resolve) => setTimeout(resolve, 2000));
        }
    }
    Logger_1.default.info("‚è∞ Timeout esperando Cloudflare");
    return false;
}
async function humanLikeBehavior(page) {
    try {
        // Obter dimens√µes da viewport
        const viewport = page.viewport();
        if (viewport) {
            const x = 100 + Math.random() * (viewport.width - 200);
            const y = 100 + Math.random() * (viewport.height - 200);
            // Movimentos de mouse mais realistas
            await page.mouse.move(x, y);
            await new Promise((resolve) => setTimeout(resolve, 100 + Math.random() * 200));
            await page.mouse.move(x + 50, y + 30);
            await new Promise((resolve) => setTimeout(resolve, 100 + Math.random() * 200));
        }
        // Scroll suave e variado
        await page.evaluate(() => {
            window.scrollBy({
                top: 100 + Math.random() * 200,
                behavior: "smooth",
            });
        });
        // Pausas vari√°veis entre a√ß√µes
        await new Promise((resolve) => setTimeout(resolve, 500 + Math.random() * 1000));
    }
    catch (error) {
        // Ignora erros de contexto/destrui√ß√£o
        Logger_1.default.info("‚ö†Ô∏è Comportamento humano interrompido (contexto alterado)");
    }
}
async function alternativeMapStrategy(page) {
    Logger_1.default.info("üîÑ Usando estrat√©gia alternativa para o mapa...");
    try {
        // 1. Tentar fechar o modal e voltar
        Logger_1.default.info("üö™ Tentando fechar modal do mapa...");
        const closed = await tryCloseModal(page);
        if (closed) {
            Logger_1.default.info("‚úÖ Modal fechado, continuando sem mapa...");
            return { success: true, mapSkipped: true };
        }
        // 2. Tentar usar coordenadas padr√£o (pular confirma√ß√£o)
        Logger_1.default.info("üìç Tentando usar coordenadas padr√£o...");
        const usedDefaults = await tryUseDefaultCoordinates(page);
        if (usedDefaults) {
            Logger_1.default.info("‚úÖ Coordenadas padr√£o aplicadas");
            return { success: true, usedDefaultCoords: true };
        }
        // 3. √öltima tentativa: recarregar contexto completo
        Logger_1.default.info("üîÑ Recarregando contexto completo...");
        await page.reload({ waitUntil: "networkidle2", timeout: 30000 });
        return { success: false };
    }
    catch (error) {
        Logger_1.default.info(`‚ùå Estrat√©gia alternativa falhou: ${error}`);
        return { success: false };
    }
}
async function tryCloseModal(page) {
    try {
        // Tentar encontrar bot√£o de fechar (X) ou Cancelar
        const closeSelectors = [
            'button[aria-label="Close"]',
            ".close",
            '[data-dismiss="modal"]',
            'button:has-text("Cancelar")',
            'button:has-text("Fechar")',
            'button:has-text("Voltar")',
            'button:has-text("Close")',
            ".modal-close",
            ".btn-close",
        ];
        for (const selector of closeSelectors) {
            try {
                const element = await page.$(selector);
                if (element) {
                    await element.click();
                    await new Promise((resolve) => setTimeout(resolve, 2000));
                    return true;
                }
            }
            catch (error) {
                continue;
            }
        }
        // Tentar ESC keyboard
        await page.keyboard.press("Escape");
        await new Promise((resolve) => setTimeout(resolve, 1000));
        return false;
    }
    catch (error) {
        return false;
    }
}
async function tryUseDefaultCoordinates(page) {
    try {
        // Tentar encontrar e preencher campos de coordenadas diretamente
        const coordinateFields = [
            'input[name="latitude"]',
            'input[name="longitude"]',
            'input[placeholder*="coord"]',
            'input[id*="coord"]',
            "#latitude",
            "#longitude",
        ];
        let filledAny = false;
        for (const selector of coordinateFields) {
            try {
                const field = await page.$(selector);
                if (field) {
                    await field.click();
                    await field.evaluate((el) => (el.value = ""));
                    await page.keyboard.type("-8.047562"); // Coordenada padr√£o Recife
                    filledAny = true;
                    await new Promise((resolve) => setTimeout(resolve, 500));
                }
            }
            catch (error) {
                continue;
            }
        }
        return filledAny;
    }
    catch (error) {
        return false;
    }
}
async function handleMapPage(page) {
    Logger_1.default.info("üó∫Ô∏è Iniciando tratamento da p√°gina do mapa...");
    // Screenshot inicial da p√°gina do mapa
    await takeDebugScreenshot(page, "01-mapa-inicial", "Estado inicial da p√°gina do mapa");
    // AGUARDAR CLOUDFLARE COM ESTRAT√âGIA MELHOR
    const cloudflareBypassed = await waitForCloudflareEnhanced(page);
    if (!cloudflareBypassed) {
        Logger_1.default.info("‚ùå Cloudflare n√£o foi contornado, tentando estrat√©gia alternativa...");
        await takeDebugScreenshot(page, "02-cloudflare-nao-resolvido", "Cloudflare n√£o foi resolvido");
        return await alternativeMapStrategy(page);
    }
    // Screenshot ap√≥s Cloudflare resolvido
    await takeDebugScreenshot(page, "03-cloudflare-resolvido", "Cloudflare resolvido com sucesso");
    // CONTINUAR COM O PROCESSO NORMAL
    return await normalMapProcess(page);
}
async function normalMapProcess(page) {
    try {
        // Aguardar um pouco para a p√°gina estabilizar
        await new Promise((resolve) => setTimeout(resolve, 2000));
        // Screenshot antes de tentar clicar no bot√£o
        await takeDebugScreenshot(page, "04-antes-confirma-endereco", "Antes de tentar clicar em 'Confirma Endere√ßo'");
        // Tentar encontrar e clicar no bot√£o de confirma√ß√£o
        const confirmButtonFound = await findAndClickElement(page, "Confirma Endere√ßo", 10000);
        if (!confirmButtonFound) {
            // Screenshot quando n√£o encontra o bot√£o principal
            await takeDebugScreenshot(page, "05-confirma-endereco-nao-encontrado", "Bot√£o 'Confirma Endere√ßo' n√£o encontrado");
            Logger_1.default.warn("üîÑ Tentando estrat√©gias alternativas para confirmar endere√ßo...");
            const alternativeTexts = [
                "Confirmar",
                "Confirma",
                "OK",
                "Aceitar",
                "Continuar",
                "Confirm",
                "Ok",
            ];
            let alternativeFound = false;
            for (const text of alternativeTexts) {
                Logger_1.default.info(`Tentando encontrar bot√£o com texto: "${text}"`);
                const found = await findAndClickElement(page, text, 3000);
                if (found) {
                    Logger_1.default.info(`‚úÖ Bot√£o alternativo encontrado: "${text}"`);
                    await takeDebugScreenshot(page, `06-botao-alternativo-${text.toLowerCase()}`, `Bot√£o alternativo '${text}' encontrado`);
                    alternativeFound = true;
                    break;
                }
            }
            if (!alternativeFound) {
                // Screenshot final quando nenhuma alternativa funciona
                await takeDebugScreenshot(page, "07-nenhuma-alternativa-encontrada", "Nenhuma alternativa de bot√£o encontrada");
                return { success: false };
            }
        }
        else {
            Logger_1.default.info("‚úÖ Bot√£o 'Confirma Endere√ßo' clicado com sucesso");
            await takeDebugScreenshot(page, "08-confirma-endereco-sucesso", "Bot√£o 'Confirma Endere√ßo' clicado com sucesso");
        }
        return { success: true };
    }
    catch (error) {
        Logger_1.default.error(`‚ùå Erro no processamento normal do mapa: ${error}`);
        return { success: false };
    }
}
// ========== FUN√á√ïES ORIGINAIS (MANTIDAS) ==========
async function findAndClickElement(page, targetText, maxWaitTime = 10000) {
    Logger_1.default.info(`üéØ === INICIANDO findAndClickElement para "${targetText}" ===`);
    // DEBUG: Verificar estado da p√°gina antes de tentar qualquer estrat√©gia
    try {
        const isPageClosed = page.isClosed();
        const pageUrl = await page.url();
        Logger_1.default.info(`üìÑ Estado da p√°gina - Fechada: ${isPageClosed}, URL: ${pageUrl}`);
        if (isPageClosed) {
            Logger_1.default.error(`‚ùå P√°gina est√° fechada, n√£o √© poss√≠vel continuar`);
            return false;
        }
    }
    catch (error) {
        Logger_1.default.error(`‚ùå Erro ao verificar estado da p√°gina: ${error}`);
        return false;
    }
    const strategies = [
        // Estrat√©gia 1: Seletor Puppeteer text
        async () => {
            try {
                Logger_1.default.info(`üîç Tentando Estrat√©gia 1 (Puppeteer text) para "${targetText}"`);
                await page.waitForSelector(`::-p-text(${targetText})`, {
                    timeout: 3000,
                });
                Logger_1.default.info(`‚úÖ Elemento encontrado com Estrat√©gia 1, clicando...`);
                await page.click(`::-p-text(${targetText})`);
                Logger_1.default.info(`‚úÖ Clique realizado com sucesso na Estrat√©gia 1`);
                return true;
            }
            catch (error) {
                Logger_1.default.info(`‚ùå Estrat√©gia 1 falhou para "${targetText}": ${error}`);
                return false;
            }
        },
        // Estrat√©gia 2: XPath com texto exato
        async () => {
            try {
                Logger_1.default.info(`üîç Tentando Estrat√©gia 2 (XPath exato) para "${targetText}"`);
                await page.waitForFunction((text) => {
                    const xpath = `//*[text()="${text}"]`;
                    return document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                }, { timeout: 3000 }, targetText);
                Logger_1.default.info(`‚úÖ Elemento encontrado com XPath exato, clicando...`);
                const found = await page.evaluate((text) => {
                    const xpath = `//*[text()="${text}"]`;
                    const element = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                    if (element) {
                        element.click();
                        return true;
                    }
                    return false;
                }, targetText);
                if (found) {
                    Logger_1.default.info(`‚úÖ Clique realizado com sucesso na Estrat√©gia 2`);
                }
                return found;
            }
            catch (error) {
                Logger_1.default.info(`‚ùå Estrat√©gia 2 falhou para "${targetText}": ${error}`);
                return false;
            }
        },
        // Estrat√©gia 3: XPath com contains (texto parcial)
        async () => {
            try {
                Logger_1.default.info(`üîç Tentando Estrat√©gia 3 (XPath contains) para "${targetText}"`);
                await page.waitForFunction((text) => {
                    const xpath = `//*[contains(text(), "${text}")]`;
                    return document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                }, { timeout: 3000 }, targetText);
                Logger_1.default.info(`‚úÖ Elemento encontrado com XPath contains, clicando...`);
                const found = await page.evaluate((text) => {
                    const xpath = `//*[contains(text(), "${text}")]`;
                    const element = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                    if (element) {
                        element.click();
                        return true;
                    }
                    return false;
                }, targetText);
                if (found) {
                    Logger_1.default.info(`‚úÖ Clique realizado com sucesso na Estrat√©gia 3`);
                }
                return found;
            }
            catch (error) {
                Logger_1.default.info(`‚ùå Estrat√©gia 3 falhou para "${targetText}": ${error}`);
                return false;
            }
        },
        // Estrat√©gia 4: Buscar por bot√µes/inputs com value ou texto similar
        async () => {
            try {
                Logger_1.default.info(`üîç Tentando Estrat√©gia 4 (busca por similaridade) para "${targetText}"`);
                const element = await page.evaluate((text) => {
                    const buttons = Array.from(document.querySelectorAll('button, input[type="button"], input[type="submit"], a'));
                    return buttons.find((btn) => {
                        const btnText = btn.textContent || btn.value || "";
                        return (btnText.toLowerCase().includes(text.toLowerCase()) ||
                            text.toLowerCase().includes(btnText.toLowerCase()));
                    });
                }, targetText);
                if (element) {
                    Logger_1.default.info(`‚úÖ Elemento similar encontrado, clicando...`);
                    await page.evaluate((text) => {
                        const buttons = Array.from(document.querySelectorAll('button, input[type="button"], input[type="submit"], a'));
                        const btn = buttons.find((btn) => {
                            const btnText = btn.textContent || btn.value || "";
                            return (btnText.toLowerCase().includes(text.toLowerCase()) ||
                                text.toLowerCase().includes(btnText.toLowerCase()));
                        });
                        if (btn) {
                            btn.click();
                        }
                    }, targetText);
                    Logger_1.default.info(`‚úÖ Clique realizado com sucesso na Estrat√©gia 4`);
                    return true;
                }
                Logger_1.default.info(`‚ùå Nenhum elemento similar encontrado na Estrat√©gia 4`);
                return false;
            }
            catch (error) {
                Logger_1.default.info(`‚ùå Estrat√©gia 4 falhou para "${targetText}": ${error}`);
                return false;
            }
        },
    ];
    const startTime = Date.now();
    while (Date.now() - startTime < maxWaitTime) {
        for (let i = 0; i < strategies.length; i++) {
            Logger_1.default.info(`üîÑ Tentando estrat√©gia ${i + 1} para encontrar "${targetText}"`);
            if (await strategies[i]()) {
                Logger_1.default.info(`‚úÖ Estrat√©gia ${i + 1} funcionou para "${targetText}"`);
                Logger_1.default.info(`üéØ === FIM findAndClickElement - SUCESSO ===`);
                return true;
            }
            // Aguardar um pouco antes da pr√≥xima estrat√©gia
            await new Promise((resolve) => setTimeout(resolve, 500));
        }
        // Aguardar antes de tentar todas as estrat√©gias novamente
        Logger_1.default.info(`‚è≥ Aguardando antes de tentar novamente... (${Math.round((Date.now() - startTime) / 1000)}s decorridos)`);
        await new Promise((resolve) => setTimeout(resolve, 1000));
    }
    // Se chegou at√© aqui, nenhuma estrat√©gia funcionou
    Logger_1.default.error(`‚ùå Nenhuma estrat√©gia funcionou para encontrar "${targetText}" ap√≥s ${Math.round(maxWaitTime / 1000)}s`);
    // Screenshot quando todas as estrat√©gias falharam
    await takeDebugScreenshot(page, `estrategias-falharam-${targetText.replace(/\s+/g, "-").toLowerCase()}`, `Todas as estrat√©gias falharam para "${targetText}"`);
    Logger_1.default.info(`üéØ === FIM findAndClickElement - FALHA ===`);
    // Debug: listar todos os elementos clic√°veis na p√°gina
    try {
        const clickableElements = await page.evaluate(() => {
            const elements = Array.from(document.querySelectorAll('button, input[type="button"], input[type="submit"], a, [onclick]'));
            return elements
                .map((el) => {
                var _a;
                return ({
                    tagName: el.tagName,
                    text: ((_a = el.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || "",
                    value: el.value || "",
                    id: el.id,
                    className: el.className,
                });
            })
                .filter((el) => el.text || el.value);
        });
        Logger_1.default.info(`Elementos clic√°veis encontrados: ${JSON.stringify(clickableElements, null, 2)}`);
    }
    catch (debugError) {
        Logger_1.default.error(`Erro no debug dos elementos: ${debugError}`);
    }
    return false;
}
async function typeWithRandomDelays(page, text, minDelay = constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.NORMAL.MIN, maxDelay = constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.NORMAL.MAX) {
    for (const char of text) {
        try {
            await ensurePageIsActive(page, `digitar caractere '${char}'`);
            await page.keyboard.type(char);
            const delay = randomTimerRange(minDelay, maxDelay);
            await new Promise((resolve) => setTimeout(resolve, delay));
        }
        catch (error) {
            Logger_1.default.error(`Erro ao digitar caractere '${char}': ${error}`);
            throw error;
        }
    }
}
// ========== FUN√á√ÉO PRINCIPAL ORIGINAL (COM MODIFICA√á√ïES NO MAPA) ==========
const viabilityService = async (page, requester, credentials, defaultFiscalRepresentative, enterpriseId) => {
    // Login
    await page.click('input[placeholder="Digite seu CPF"]');
    await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
    await typeWithRandomDelays(page, credentials.cpf, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.FAST.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.FAST.MAX);
    await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
    await page.click('input[placeholder="Digite sua Senha."]');
    await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
    await typeWithRandomDelays(page, credentials.password, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.FAST.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.FAST.MAX);
    await page.click("::-p-text(Entrar)");
    await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
    await page.click("::-p-text(Viabilidade)");
    await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
    let maxRetries = 5;
    let retryCount = 0;
    let viabilidadeFormPage;
    for (let i = 0; i < maxRetries; i++) {
        Logger_1.default.info(`Tentativa ${retryCount + 1} para clicar em 'Pedido de Viabilidade'`);
        await page.click("::-p-text(Pedido de Viabilidade)");
        Logger_1.default.info("Clicado em Pedido de Viabilidade");
        await new Promise((resolve) => setTimeout(resolve, randomTimerRange(2000, 3000)));
        const browser = page.browser();
        const pages = await browser.pages();
        Logger_1.default.info(`Total de paginas: ${pages.length}`);
        viabilidadeFormPage = pages[pages.length - 1];
        Logger_1.default.info("Pagina atual: Pedido de Viabilidade");
        Logger_1.default.info("Procurando pelo seletor #drpListaMucinicpios");
        const selectCity = await viabilidadeFormPage.waitForSelector("#drpListaMucinicpios", { timeout: 5000 });
        if (!selectCity) {
            Logger_1.default.info("Selector #drpListaMucinicpios n√£o encontrado!");
            retryCount++;
            continue;
        }
        Logger_1.default.info("Selector #drpListaMucinicpios encontrado com sucesso!");
        const cityValue = requester.city.toUpperCase();
        const institutionValue = requester.institution.toUpperCase();
        try {
            // Aguardar um pouco para garantir que a p√°gina est√° est√°vel
            await new Promise((resolve) => setTimeout(resolve, 500));
            // Verificar se a p√°gina ainda est√° ativa antes de cada opera√ß√£o
            await ensurePageIsActive(viabilidadeFormPage, "focar no dropdown de cidades");
            // Opera√ß√£o mais robusta para selecionar cidade
            Logger_1.default.info("Iniciando sele√ß√£o da cidade...");
            const citySelectionSuccess = await viabilidadeFormPage.evaluate((cityValue) => {
                try {
                    const select = document.querySelector("#drpListaMucinicpios");
                    if (!select)
                        return false;
                    const options = Array.from(select.querySelectorAll("option"));
                    const targetOption = options.find((opt) => { var _a; return (_a = opt.textContent) === null || _a === void 0 ? void 0 : _a.includes(cityValue); });
                    if (targetOption) {
                        select.value = targetOption.value;
                        // Disparar evento change
                        const event = new Event("change", { bubbles: true });
                        select.dispatchEvent(event);
                        return true;
                    }
                    return false;
                }
                catch (error) {
                    console.error("Erro na sele√ß√£o da cidade:", error);
                    return false;
                }
            }, cityValue);
            if (!citySelectionSuccess) {
                throw new Error(`N√£o foi poss√≠vel selecionar a cidade: ${cityValue}`);
            }
            Logger_1.default.info(`‚úÖ Cidade selecionada: ${cityValue}`);
            // Aguardar ap√≥s sele√ß√£o da cidade
            await new Promise((resolve) => setTimeout(resolve, 1000));
            await ensurePageIsActive(viabilidadeFormPage, "aguardar dropdown de institui√ß√µes");
            // Aguardar o dropdown da institui√ß√£o aparecer
            Logger_1.default.info("Aguardando dropdown de institui√ß√µes...");
            await viabilidadeFormPage.waitForSelector("#drpListaOpcoes", {
                timeout: 5000,
            });
            await new Promise((resolve) => setTimeout(resolve, 500));
            await ensurePageIsActive(viabilidadeFormPage, "selecionar institui√ß√£o");
            // Opera√ß√£o mais robusta para selecionar institui√ß√£o
            Logger_1.default.info("Iniciando sele√ß√£o da institui√ß√£o...");
            const institutionSelectionSuccess = await viabilidadeFormPage.evaluate((institutionValue) => {
                try {
                    const select = document.querySelector("#drpListaOpcoes");
                    if (!select)
                        return false;
                    const options = Array.from(select.querySelectorAll("option"));
                    const targetOption = options.find((opt) => { var _a; return (_a = opt.textContent) === null || _a === void 0 ? void 0 : _a.includes(institutionValue); });
                    if (targetOption) {
                        select.value = targetOption.value;
                        // Disparar evento change
                        const event = new Event("change", { bubbles: true });
                        select.dispatchEvent(event);
                        return true;
                    }
                    return false;
                }
                catch (error) {
                    console.error("Erro na sele√ß√£o da institui√ß√£o:", error);
                    return false;
                }
            }, institutionValue);
            if (!institutionSelectionSuccess) {
                throw new Error(`N√£o foi poss√≠vel selecionar a institui√ß√£o: ${institutionValue}`);
            }
            Logger_1.default.info(`‚úÖ Institui√ß√£o selecionada: ${institutionValue}`);
            await new Promise((resolve) => setTimeout(resolve, 500));
            await ensurePageIsActive(viabilidadeFormPage, "clicar em Matriz");
            await viabilidadeFormPage.click("#chkEmpresa");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            Logger_1.default.info(`Selecionado Matriz`);
            await ensurePageIsActive(viabilidadeFormPage, "avan√ßar para pr√≥xima p√°gina");
            const advanceButtonFound = await findAndClickElement(viabilidadeFormPage, "Avan√ßar", 10000);
            if (!advanceButtonFound) {
                throw new Error("N√£o foi poss√≠vel encontrar o bot√£o 'Avan√ßar' ap√≥s m√∫ltiplas tentativas");
            }
            Logger_1.default.info(`‚úÖ Bot√£o 'Avan√ßar' clicado com sucesso`);
            // Aguardar navega√ß√£o para pr√≥xima p√°gina
            await new Promise((resolve) => setTimeout(resolve, 1500));
            /**
             * Preenche o formulario na proxima pagina
             */
            Logger_1.default.info("Pagina atual: Solicitante e Pessoa Jur√≠dica");
            await viabilidadeFormPage.click("#txtIPTU");
            await typeWithRandomDelays(viabilidadeFormPage, requester.townRegistry, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.FAST.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.FAST.MAX);
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.click("#txtArea");
            await typeWithRandomDelays(viabilidadeFormPage, requester.commercialEstablishmentArea, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MAX);
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.click("#drpEnviaSefaz");
            await viabilidadeFormPage.focus("#drpEnviaSefaz");
            await viabilidadeFormPage.keyboard.press("ArrowDown");
            await viabilidadeFormPage.keyboard.type(requester.isStateRegistryRequested[0]);
            await viabilidadeFormPage.keyboard.press("Enter");
            Logger_1.default.info(`Selecionado op√ß√£o se solicitar√° inscri√ß√£o estadual: "${requester.isStateRegistryRequested}" usando teclado`);
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.click("#drpTipoRegistro");
            const tipoRegistroOptionValue = await viabilidadeFormPage.evaluate(() => {
                const select = document.querySelector("#drpTipoRegistro");
                const options = select
                    ? Array.from(select.querySelectorAll("option"))
                    : [];
                const targetOption = options.find((opt) => { var _a; return (_a = opt.textContent) === null || _a === void 0 ? void 0 : _a.includes("Sociedade"); });
                return targetOption ? targetOption.value : null;
            });
            if (tipoRegistroOptionValue) {
                await viabilidadeFormPage.select("#drpTipoRegistro", tipoRegistroOptionValue);
                Logger_1.default.info(`Selecionado op√ß√£o tipo juridico: "Sociedade"`);
            }
            else {
                Logger_1.default.error('N√£o foi poss√≠vel encontrar a op√ß√£o "Sociedade"');
            }
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.click("#drpnaturezaJuridica");
            const optionValue = await viabilidadeFormPage.evaluate(() => {
                const select = document.querySelector("#drpnaturezaJuridica");
                const options = select
                    ? Array.from(select.querySelectorAll("option"))
                    : [];
                const targetOption = options.find((opt) => { var _a; return (_a = opt.textContent) === null || _a === void 0 ? void 0 : _a.includes("Sociedade Unipessoal de Advocacia"); });
                return targetOption ? targetOption.value : null;
            });
            if (optionValue) {
                await viabilidadeFormPage.select("#drpnaturezaJuridica", optionValue);
            }
            else {
                Logger_1.default.error('N√£o foi poss√≠vel encontrar a op√ß√£o "Sociedade Unipessoal de Advocacia"');
            }
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.click("::-p-text(Internet)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.waitForSelector("#txtCodigoImovel", {
                timeout: 5000,
            });
            await viabilidadeFormPage.click("#txtCodigoImovel");
            await typeWithRandomDelays(viabilidadeFormPage, requester.propertySequentialNumber, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MAX);
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.click("::-p-text(Buscar Im√≥vel)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            /**
             * Verifica se o button altera para Validado, se nao, tira print e lan√ßa exception
             */
            const button = await viabilidadeFormPage.$("::-p-text(Validado)");
            if (!button) {
                Logger_1.default.error("Sequencial do Im√≥vel n√£o foi validada - bot√£o 'Validado' n√£o encontrado");
                throw new Error("Sequencial do Im√≥vel n√£o foi validada");
            }
            await viabilidadeFormPage.click("#txtReferencia");
            requester.referencePoint
                ? await typeWithRandomDelays(viabilidadeFormPage, requester.referencePoint, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MAX)
                : await typeWithRandomDelays(viabilidadeFormPage, "N√ÉO SE APLICA", constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MAX);
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.click("::-p-text(Visualizar Mapa)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange(constants_1.BOT_SPEED_CONFIG.SPECIAL_DELAYS.PAGE_LOAD.MIN, constants_1.BOT_SPEED_CONFIG.SPECIAL_DELAYS.PAGE_LOAD.MAX)));
            /**
             * Abre outra pagina com o mapa
             */
            const browser2 = viabilidadeFormPage.browser();
            const pages2 = await browser2.pages();
            Logger_1.default.info(`Total de paginas: ${pages2.length}`);
            const mapAddressPage = pages2[pages2.length - 1];
            Logger_1.default.info("Pagina atual: Mapa - confirma√ß√£o de coordenadas");
            // Screenshot da p√°gina do mapa logo ap√≥s abrir
            await takeDebugScreenshot(mapAddressPage, "00-mapa-aberto", "P√°gina do mapa rec√©m aberta");
            await new Promise((resolve) => setTimeout(resolve, 3000));
            const mapPageUrl = await mapAddressPage.url();
            const mapPageTitle = await mapAddressPage.title();
            Logger_1.default.info(`URL da p√°gina do mapa: ${mapPageUrl}`);
            Logger_1.default.info(`T√≠tulo da p√°gina do mapa: ${mapPageTitle}`);
            // ========== SUBSTITUI√á√ÉO DA PARTE DO CLOUDFLARE ==========
            Logger_1.default.info("üìç Processando p√°gina do mapa com estrat√©gia anti-Cloudflare...");
            const mapResult = await handleMapPage(mapAddressPage);
            if (!mapResult.success) {
                if (mapResult.mapSkipped) {
                    Logger_1.default.info("‚ö†Ô∏è Mapa pulado, continuando processo...");
                    // Continue o fluxo mesmo sem o mapa - tente voltar e avan√ßar
                    try {
                        await mapAddressPage.close();
                        await new Promise((resolve) => setTimeout(resolve, 2000));
                        // Tentar avan√ßar sem confirma√ß√£o do mapa
                        const advanced = await findAndClickElement(viabilidadeFormPage, "Avan√ßar", 5000);
                        if (advanced) {
                            Logger_1.default.info("‚úÖ Avan√ßado sem confirma√ß√£o do mapa");
                        }
                        else {
                            throw new Error("N√£o foi poss√≠vel avan√ßar sem o mapa");
                        }
                    }
                    catch (error) {
                        const errorMessage = error instanceof Error ? error.message : String(error);
                        Logger_1.default.error(`‚ùå Erro ao continuar sem mapa: ${errorMessage}`);
                        throw new Error(`Falha no processo do mapa: ${errorMessage}`);
                    }
                }
                else {
                    throw new Error("N√£o foi poss√≠vel processar a p√°gina do mapa");
                }
            }
            else {
                Logger_1.default.info("‚úÖ Mapa processado com sucesso");
            }
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            /**
             * Volta para pagina anterior - Viabilidade
             */
            await viabilidadeFormPage.click("::-p-text(Avan√ßar)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            /**
             * Preenche formulario Quadro Societ√°rio
             */
            await Promise.all(requester.ownershipStructure.map(async (partner, index) => {
                if (requester.ownershipStructure.length > 1 &&
                    index === requester.ownershipStructure.length - 1) {
                    return;
                }
                await viabilidadeFormPage.waitForSelector("#CpfSocio", {
                    timeout: 10000,
                });
                await viabilidadeFormPage.click("#CpfSocio");
                await typeWithRandomDelays(viabilidadeFormPage, partner.cpf, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MAX);
                const addButton = await viabilidadeFormPage.waitForSelector("::-p-text(Adicionar)", {
                    visible: true,
                    timeout: 10000,
                });
                await (addButton === null || addButton === void 0 ? void 0 : addButton.click());
                await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            }));
            await viabilidadeFormPage.click("::-p-text(Avan√ßar)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            /**
             * Preenche formulario Nome Empresarial, Objeto Social e CNAE
             */
            await viabilidadeFormPage.click("#txtOpcao1");
            await typeWithRandomDelays(viabilidadeFormPage, requester.enterpriseName, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.NORMAL.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.NORMAL.MAX);
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.click("#txtObjeto");
            await typeWithRandomDelays(viabilidadeFormPage, requester.enterprisePurpose, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MAX);
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.click("::-p-text(Avan√ßar)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            /**
             * Preenche formulario Informa√ß√µes Complementares
             */
            await viabilidadeFormPage.waitForSelector("#pnPrincipal input:first-of-type", { timeout: 3000 });
            await viabilidadeFormPage.click("#pnPrincipal input:first-of-type");
            await typeWithRandomDelays(viabilidadeFormPage, requester.additionalInformation.builtArea, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MAX);
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.keyboard.press("Tab");
            await typeWithRandomDelays(viabilidadeFormPage, requester.additionalInformation.requestorPhone, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MAX);
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.keyboard.press("Tab");
            await typeWithRandomDelays(viabilidadeFormPage, defaultFiscalRepresentative.name, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.NORMAL.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.NORMAL.MAX);
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.keyboard.press("Tab");
            await typeWithRandomDelays(viabilidadeFormPage, defaultFiscalRepresentative.cpf, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MAX);
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.keyboard.press("Tab");
            await typeWithRandomDelays(viabilidadeFormPage, defaultFiscalRepresentative.phone, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MAX);
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            // Preenche o protocolo SEPUL - campo 6
            Logger_1.default.info("Procurando campo do protocolo SEPUL...");
            let sepulFieldFilled = false;
            try {
                await viabilidadeFormPage.keyboard.press("Tab");
                await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
                const sepulValue = requester.sepulRecifeProtocol || "0";
                await typeWithRandomDelays(viabilidadeFormPage, sepulValue, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MAX);
                Logger_1.default.info(`Protocolo SEPUL preenchido via Tab: ${sepulValue}`);
                sepulFieldFilled = true;
            }
            catch (error) {
                Logger_1.default.error(`Erro ao preencher SEPUL via Tab: ${error}`);
            }
            if (!sepulFieldFilled) {
                try {
                    Logger_1.default.info("Tentando encontrar campo SEPUL por seletor...");
                    const inputs = await viabilidadeFormPage.$$('input[type="text"], input:not([type])');
                    Logger_1.default.info(`Encontrados ${inputs.length} campos de texto`);
                    if (inputs.length >= 6) {
                        const sepulField = inputs[5];
                        await sepulField.click();
                        await sepulField.evaluate((el) => (el.value = ""));
                        const sepulValue = requester.sepulRecifeProtocol || "0";
                        await typeWithRandomDelays(viabilidadeFormPage, sepulValue, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MIN, constants_1.BOT_SPEED_CONFIG.TYPING_SPEED.SLOW.MAX);
                        Logger_1.default.info(`Protocolo SEPUL preenchido via seletor: ${sepulValue}`);
                        sepulFieldFilled = true;
                    }
                }
                catch (error) {
                    Logger_1.default.error(`Erro ao preencher SEPUL via seletor: ${error}`);
                }
            }
            if (!sepulFieldFilled) {
                Logger_1.default.error("AVISO: N√£o foi poss√≠vel preencher o campo SEPUL automaticamente");
            }
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await viabilidadeFormPage.click("::-p-text(Preencher Formul√°rio)");
            Logger_1.default.info("Clicado em 'Preencher Formul√°rio'");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange(3000, 5000)));
            /**
             * Verifica se uma nova p√°gina dos bombeiros foi aberta
             */
            const browser3 = viabilidadeFormPage.browser();
            const pages3 = await browser3.pages();
            Logger_1.default.info(`Total de p√°ginas ap√≥s clicar em 'Preencher Formul√°rio': ${pages3.length}`);
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange(5000, 7000)));
            let bombeirosPage = pages3[pages3.length - 1];
            if (pages3.length <= 3) {
                Logger_1.default.info("Nova p√°gina n√£o detectada, tentando aguardar mais...");
                await new Promise((resolve) => setTimeout(resolve, randomTimerRange(2000, 4000)));
                const updatedPages = await browser3.pages();
                Logger_1.default.info(`P√°ginas atualizadas: ${updatedPages.length}`);
                bombeirosPage = updatedPages[updatedPages.length - 1];
            }
            const currentUrl = await bombeirosPage.url();
            Logger_1.default.info(`URL da p√°gina dos bombeiros: ${currentUrl}`);
            const pageTitle = await bombeirosPage.title();
            Logger_1.default.info(`T√≠tulo da p√°gina: ${pageTitle}`);
            Logger_1.default.info("P√°gina atual: Formul√°rio Bombeiros");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange(3000, 5000)));
            /**
             * Procura pelo bot√£o "Inciar" na p√°gina dos bombeiros
             */
            let iniciarButton = null;
            const pageContent = await bombeirosPage.content();
            const hasBombeirosContent = pageContent.includes("bombeiro") ||
                pageContent.includes("Bombeiro") ||
                pageContent.includes("BOMBEIRO") ||
                pageContent.includes("inciar") ||
                pageContent.includes("Inciar");
            Logger_1.default.info(`P√°gina cont√©m conte√∫do dos bombeiros: ${hasBombeirosContent}`);
            if (!hasBombeirosContent) {
                Logger_1.default.error("ERRO: N√£o estamos na p√°gina dos bombeiros!");
                await new Promise((resolve) => setTimeout(resolve, 10000));
                const allPages = await browser3.pages();
                Logger_1.default.info(`Todas as p√°ginas abertas: ${allPages.length}`);
                for (let i = 0; i < allPages.length; i++) {
                    const url = await allPages[i].url();
                    const title = await allPages[i].title();
                    Logger_1.default.info(`P√°gina ${i}: URL=${url}, T√≠tulo=${title}`);
                }
            }
            const possibleTexts = ["Inciar", "INCIAR", "Iniciar", "INICIAR"];
            for (const text of possibleTexts) {
                try {
                    Logger_1.default.info(`Procurando bot√£o com o texto: "${text}"`);
                    iniciarButton = await bombeirosPage.waitForSelector(`::-p-text(${text})`, {
                        timeout: 3000,
                    });
                    if (iniciarButton) {
                        Logger_1.default.info(`Bot√£o encontrado com o texto: "${text}"`);
                        await bombeirosPage.focus(`::-p-text(${text})`);
                        await new Promise((resolve) => setTimeout(resolve, randomTimerRange(constants_1.BOT_SPEED_CONFIG.SPECIAL_DELAYS.IMPORTANT_CLICK.MIN, constants_1.BOT_SPEED_CONFIG.SPECIAL_DELAYS.IMPORTANT_CLICK.MAX)));
                        await bombeirosPage.click(`::-p-text(${text})`);
                        break;
                    }
                }
                catch (error) {
                    Logger_1.default.info(`Bot√£o n√£o encontrado com o texto: "${text}"`);
                    continue;
                }
            }
            if (!iniciarButton) {
                try {
                    Logger_1.default.info("Tentando encontrar bot√£o por outros seletores...");
                    await bombeirosPage.waitForSelector('input[type="button"], button, input[type="submit"]', { timeout: 5000 });
                    const buttons = await bombeirosPage.$$eval('input[type="button"], button, input[type="submit"]', (buttons) => buttons.map((btn) => ({
                        text: btn.textContent || btn.value || "",
                        tagName: btn.tagName,
                        type: btn.type,
                    })));
                    Logger_1.default.info(`Bot√µes encontrados na p√°gina: ${JSON.stringify(buttons, null, 2)}`);
                    throw new Error("N√£o foi poss√≠vel encontrar o bot√£o Inciar na p√°gina dos bombeiros");
                }
                catch (debugError) {
                    Logger_1.default.error(`Erro no debug dos bot√µes: ${debugError}`);
                    throw new Error("N√£o foi poss√≠vel encontrar o bot√£o Inciar na p√°gina dos bombeiros");
                }
            }
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            // Sequ√™ncia de cliques no formul√°rio dos bombeiros
            await bombeirosPage.click("::-p-text(At√© 200 m¬≤)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(Avan√ßar)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(N√£o)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(Exclusivamente t√©rreo)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(Avan√ßar)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(N√£o)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(Avan√ßar)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(N√£o)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(Avan√ßar)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(N√£o)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(N√£o)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(N√£o)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(N√£o)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(N√£o)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(Avan√ßar)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(N√£o)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(Avan√ßar)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(N√£o)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(Avan√ßar)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(N√£o)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(N√£o)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            await bombeirosPage.click("::-p-text(Confirmar)");
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange()));
            Logger_1.default.info("Formul√°rio dos Bombeiros preenchido com sucesso");
            // Finaliza√ß√£o: Enviar a viabilidade
            Logger_1.default.info("Procurando bot√£o 'Enviar' para finalizar...");
            // Tentar encontrar o bot√£o "Enviar" primeiro na p√°gina dos bombeiros
            let enviarButtonFound = await findAndClickElement(bombeirosPage, "Enviar", 5000);
            if (enviarButtonFound) {
                Logger_1.default.info("‚úÖ Bot√£o 'Enviar' encontrado e clicado na p√°gina dos bombeiros");
            }
            else {
                Logger_1.default.info("Bot√£o 'Enviar' n√£o encontrado na p√°gina dos bombeiros, tentando na p√°gina principal...");
                enviarButtonFound = await findAndClickElement(viabilidadeFormPage, "Enviar", 5000);
                if (enviarButtonFound) {
                    Logger_1.default.info("‚úÖ Bot√£o 'Enviar' encontrado e clicado na p√°gina principal");
                }
                else {
                    Logger_1.default.error("‚ùå Bot√£o 'Enviar' n√£o encontrado em nenhuma p√°gina");
                    try {
                        const buttons = await viabilidadeFormPage.$$eval('button, input[type="button"], input[type="submit"]', (buttons) => buttons.map((btn) => ({
                            text: btn.textContent || btn.value || "",
                            type: btn.type,
                            id: btn.id,
                            className: btn.className,
                        })));
                        Logger_1.default.info(`Bot√µes encontrados na p√°gina principal: ${JSON.stringify(buttons, null, 2)}`);
                    }
                    catch (debugError) {
                        Logger_1.default.error(`Erro no debug dos bot√µes: ${debugError}`);
                    }
                    throw new Error("N√£o foi poss√≠vel encontrar o bot√£o 'Enviar'");
                }
            }
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange(15000, 20000)));
            try {
                Logger_1.default.info("Viabilidade finalizada com sucesso, processando relat√≥rio...");
                // Extrai o n√∫mero do protocolo da mensagem de sucesso
                let protocolNumber = null;
                try {
                    const successElement = await viabilidadeFormPage.$("::-p-text(Viabilidade concluida com sucesso)");
                    if (successElement) {
                        const fullText = await successElement.evaluate((el) => el.textContent);
                        Logger_1.default.info(`Texto completo encontrado: ${fullText}`);
                        const protocolMatch = fullText === null || fullText === void 0 ? void 0 : fullText.match(/PEP\d+/);
                        if (protocolMatch) {
                            protocolNumber = protocolMatch[0];
                            Logger_1.default.info(`Protocolo extra√≠do: ${protocolNumber}`);
                        }
                    }
                    if (!protocolNumber) {
                        const allText = await viabilidadeFormPage.evaluate(() => {
                            return document.body.innerText;
                        });
                        const protocolMatch = allText.match(/PEP\d+/);
                        if (protocolMatch) {
                            protocolNumber = protocolMatch[0];
                            Logger_1.default.info(`Protocolo encontrado no texto da p√°gina: ${protocolNumber}`);
                        }
                    }
                }
                catch (protocolError) {
                    Logger_1.default.error(`Erro ao extrair protocolo: ${protocolError}`);
                }
                // Clica no bot√£o "Ver Relat√≥rio" e baixa o arquivo
                Logger_1.default.info("Procurando bot√£o 'Ver Relat√≥rio'...");
                let reportFileUrl = null;
                try {
                    await viabilidadeFormPage.waitForSelector("::-p-text(Ver Relat√≥rio)", { timeout: 5000 });
                    await viabilidadeFormPage.click("::-p-text(Ver Relat√≥rio)");
                    Logger_1.default.info("Clicado em 'Ver Relat√≥rio'");
                    await new Promise((resolve) => setTimeout(resolve, randomTimerRange(3000, 5000)));
                    const browser = viabilidadeFormPage.browser();
                    const allPages = await browser.pages();
                    Logger_1.default.info(`Total de p√°ginas ap√≥s clicar Ver Relat√≥rio: ${allPages.length}`);
                    let relatorioPage = allPages[allPages.length - 1];
                    if (allPages.length <= 4) {
                        Logger_1.default.info("Relat√≥rio pode ter aberto na mesma p√°gina");
                        relatorioPage = viabilidadeFormPage;
                    }
                    await new Promise((resolve) => setTimeout(resolve, randomTimerRange(2000, 4000)));
                    // Gera o PDF diretamente em buffer para upload
                    let reportBuffer;
                    let fileName;
                    try {
                        const pdfBuffer = await relatorioPage.pdf({
                            format: "A4",
                            printBackground: true,
                            margin: {
                                top: "20px",
                                right: "20px",
                                bottom: "20px",
                                left: "20px",
                            },
                        });
                        reportBuffer = Buffer.from(pdfBuffer);
                        fileName = `${requester.enterpriseName}-RELATORIO-${protocolNumber || Date.now()}.pdf`;
                        Logger_1.default.info(`Relat√≥rio gerado como PDF em mem√≥ria`);
                    }
                    catch (pdfError) {
                        Logger_1.default.error(`Erro ao gerar PDF: ${pdfError}`);
                        Logger_1.default.info(`Tentando gerar screenshot como fallback...`);
                        const screenshotBuffer = await relatorioPage.screenshot({
                            fullPage: true,
                        });
                        reportBuffer = Buffer.from(screenshotBuffer);
                        fileName = `${requester.enterpriseName}-RELATORIO-${protocolNumber || Date.now()}.png`;
                        Logger_1.default.info(`Relat√≥rio gerado como screenshot em mem√≥ria`);
                    }
                    // Upload do relat√≥rio diretamente do buffer para o S3
                    Logger_1.default.info(`Fazendo upload do relat√≥rio: ${fileName}`);
                    const uploadPath = `viabilidade-reports/${protocolNumber || Date.now()}/${fileName}`;
                    const uploadResult = await (0, handler_upload_files_to_spaces_1.uploadFileToS3)(reportBuffer, fileName, uploadPath);
                    reportFileUrl = uploadResult;
                    Logger_1.default.info(`Upload do relat√≥rio conclu√≠do: ${uploadResult}`);
                }
                catch (relatorioError) {
                    Logger_1.default.error(`Erro ao processar/upload relat√≥rio: ${relatorioError}`);
                }
                const result = {
                    success: true,
                    protocolNumber: protocolNumber || "PROTOCOLO_NAO_ENCONTRADO",
                    enterpriseName: requester.enterpriseName,
                    enterpriseId: enterpriseId,
                    reportFileUrl: reportFileUrl,
                    processedAt: new Date().toISOString(),
                    processingTime: "N/A", // Pode ser calculado se necess√°rio
                    botResponse: "Processo finalizado com sucesso",
                    attempts: retryCount + 1,
                    requestData: {
                        city: requester.city,
                        institution: requester.institution,
                        townRegistry: requester.townRegistry,
                        propertySequentialNumber: requester.propertySequentialNumber,
                        sepulRecifeProtocol: requester.sepulRecifeProtocol || "0",
                    },
                };
                Logger_1.default.info(`Processo conclu√≠do com sucesso: ${JSON.stringify(result, null, 2)}`);
                return result;
            }
            catch (finalError) {
                Logger_1.default.error(`Erro na finaliza√ß√£o: ${finalError}`);
                return {
                    success: true,
                    protocolNumber: "ERRO_AO_OBTER_PROTOCOLO",
                    enterpriseName: requester.enterpriseName,
                    enterpriseId: enterpriseId,
                    botResponse: "Erro ao obter protocolo, mas processo foi executado",
                    attempts: retryCount + 1,
                };
            }
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : "Unknown error";
            Logger_1.default.error(`Tentativa ${retryCount + 1} falhou: ${errorMessage}`);
            // Verificar se √© um erro de contexto destru√≠do
            if (errorMessage.includes("Execution context was destroyed") ||
                errorMessage.includes("P√°gina foi fechada")) {
                Logger_1.default.info("Erro de contexto destru√≠do detectado - reiniciando processo");
            }
            retryCount++;
            const browser = page.browser();
            const pages = await browser.pages();
            if (pages.length > 2) {
                Logger_1.default.info("Fechando a p√°gina atual para tentar novamente");
                try {
                    await pages[pages.length - 1].close();
                }
                catch (closeError) {
                    Logger_1.default.error(`Erro ao fechar p√°gina: ${closeError}`);
                }
            }
            // Aguardar um pouco antes de tentar novamente
            await new Promise((resolve) => setTimeout(resolve, 1000));
            await new Promise((resolve) => setTimeout(resolve, randomTimerRange(2000, 3000)));
        }
    }
    throw new Error("Falha ap√≥s todas as tentativas");
};
exports.viabilityService = viabilityService;
//# sourceMappingURL=viability-service.js.map